---
layout: post
title:  "5. 3차원 표현"
date:   2021-01-25 16:09:01 +0900
categories: jekyll update
---
#### Table of Contents
  1.　[3차원의 단서](#1-com-객체)<br />
  2.　[전면버퍼(front buffer)와 후면버퍼(back buffer)](#2-전면버퍼front-buffer와-후면버퍼back-buffer)<br />
  3.　[깊이 버퍼(Depth buffer)](#3-깊이-버퍼depth-buffer)<br />
  4.　[자원과 서술자(View)](#4-자원과-서술자view)<br />　　
    *　[뷰의 종류](#뷰의-종류)<br />　　
    *　[자원과 서술자(View)](#뷰의-특성)<br />
  5.　[샘플링(Sampling)](#5-샘플링sampling)<br />
  6.　[기능 수준(feature level)](#6-기능-수준feature-level)<br />
  7.　[DXGI (DirectX Graphics Infrastructure)](#7-dxgi-directx-graphics-infrastructure)<br />
  8.　[상주성(Residency)](#8-상주성residency)<br />
<br />
<br />
**<span style="color:red"></span>**

### **1. 3차원의 단서**
모니터의 2차원 화면에서 3차원의 입체감을 느낄 수 있는 단서는 다음과 같은 요소들이 존재한다.

- 빛과 음영
- 그림자
- 물체 겹침(깊이)
- 소실점 (vanishing point(원근감))

<br />
<br />
<br />
<br />

### **2. Direcct에서의 근사**
- 삼각형 Mesh로 이루어진 3D모델을 다룸
- 보통 3D모델은 모델러라 불리우는 전문 툴을 사용해서 제작함(3dmax, maya등)
- 삼각형 정점 나열로 만든 구나 원기둥도 사용가능함


<br />
<br />
<br />
<br />

### **3. 색연산**

- RGB : 컴퓨터의 색상은 RGB의 적절한 혼합으로 이루어짐
- RGB자체를 하나의 색 벡터로 표현할 수 있다.
- RGB벡터
  - RGB벡터에선 합연산 뺄셈 스칼라 곱등이 적용된다
  - RGB벡터 연산에선 내적 외적은 의미가 없다
  - RGB벡터 연산만의 특이점이 있는데 바로 변조(modulation)이다.
  - 변조는 성분별 곱셈인데 이 연산은 주로 조명공식에 사용된다.
  - DirectX에서 RGB 성분을 담는 자료형은 XMVECTOR이다. XMVECTOR는 32비트 부동소수점 4개로 이루어져있다.
- 클램핑(Clamping)
  - 색 벡터에서 각 성분은 0~1의 값을 가진다.
  - 연산중 각 성분이 0아래로 내려가거나 1을 초과하는 수치가 생길수 있다. 이때 해당 성분은 0또는 1로 한정시켜야한다. 이를 클램핑이라고 한다.
- 128비트 색상
  - 색 벡터를 표현할때는 RGB값 외에 a라는 알파채널이 포함된다. 
  - 알파는 색의 불투명도를 결정하는 0~1사이의 값이다
  - RGBA를 각각 32비트 부동소수점으로 표현하면 하나의 색상은 128비트가된다.
  - 이는 XMVECTOR하나로 다룰수 있고 이에따라 SIMD연산이 가능해지는 혜택을 얻는다.
  - 색벡터 모듈레이션 함수는 DirectXMath 헤더 내부의 XMColorModulate이다
  - 산술 오차가 적어야 유리한 픽셀 셰이더 등에서 사용된다.



<br />
<br />
<br />
<br />

### **4. 자원과 서술자(View)**


 
　서술자(View)는 GPU가 자원을 어떤 단계의 파이프라인에 묶을것(BInd)할 것인지에 대해 서술하는 간접 층이다.
이러한 **<span style="color:red">간접층을 두는 이유는 리소스 자체에는 해당 리소스를 어떤 단계에 써야하는지, 
어느만큼 적용시켜야하는지에 대한 명시를 같이 포함하고 있지 않기 때문</span>**이다. 
또한 무형식으로 생성된 리소스를 서술자가 구체적으로 형식을 명시해 사용할 수 있게 만들어 주는 역할도 한다.<br>
<br>

#### 뷰의 종류
뷰에는 다음과 같은 종류가 있다<br>

- ConstBuffer View (상수 버퍼를 관리하는 서술자)<br />
- Shader Resource View (쉐이더를 관리하는 서술자)<br />
- Unordered acceess view (순서 없는 접근 관리 서술자)<br />
- Sampler State View ( 표본추출기(sampler)를 관리하는 서술자)<br />
- Render Target View( 렌더 대상을 관리하는 서술자)<br />
- Depth Stencil View (깊이와 스탠실을 관리하는 서술자)<br /><br />

#### 뷰의 특성
뷰들은 다음과 같은 특성이 있다.<br>

 - 이러한 **<span style="color:red">뷰들은 서술자힙(descriptor heap)에 저장</span>**된다.
 - 서술자 종류마다 개별적인 서술자 힙이 필요하다.<br />
 - 하나의 자원에 여러종류의 서술자가 참조할 수있다.<br />
 예를 들어 텍스쳐렌더에 쓰인 텍스쳐가 쉐이더 단계로 넘어가서 색을 표시하는데 사용될 수도 있다.

서술자들은 응용 프로그램 초기화 시점에서 생성하는 것이 
실행 시점에서 생성하는것보다 낫다.<br>
(무형식 자원은 정말 필요할 때에만 사용하는것이 최적화를 위한 지름길이다)



<br />
<br />
<br />
<br />


### **5. 샘플링(Sampling)**
　 **<span style="color:red">샘플링(Sampling)은 계단현상(aliasing)을 제거하는 기법</span>**을 일컬으며 안티 엘리어싱(anti aliasing)이라고도 한다.<br><br><br />
　샘플링엔 다음과 같은 기법이 있다.<br>

- **SuperSampling**<br>
이 기법은 후면버퍼 크기를 전면의 4배로 잡고 물체를 그린다음 전면으로 이동시키는 방법이다. 이는 전면버퍼에 비해 4배 많은 픽셀값을 계산해야 하므로 메모리 소비량이 매우 높아진다는 단점이 있다. 대신 부분 픽셀값이 서로 다른 색을 가지므로 정확도가 높다<br>

- **MultiSampling** (다중표본화)<br>
슈퍼 샘플링의 메모리 소모 문제를 해결하기 위해 절충적으로 나온 안티엘리어싱 기법이 다중표본화(MultiSampling)이다.
다중표본화는 픽셀 하나를 4부분으로 쪼개지만 픽셀당 한번만 색을 계산하는 기법이다. 계산횟수가 상대적으로 낮다.<br><br /> 

파이프 라인 단계에서 가장 높은 비용(계산량)을 필요로 하는 단계가 색을 계산하는 단계이다. 따라서 다중표본화는 픽셀당 한번계산이고 슈퍼샘플링은 픽셀당 부분픽셀 4번 계산하므로 비용이 상당히 낮다. 하지만 정확도는 슈퍼샘플링이 훨씬 높다.

D3D에서 다중표본화를 사용하기 위해서는 DXGI_SAMPLE_DESC라는 구조체를 적절히 채워서 스왑체인과 깊이버퍼에 적절히 설정해줘야한다. 후면버퍼와 깊이버퍼를 생성할때 동일한 샘플러를 적용해야한다.<br>




<br />
<br />
<br />
<br />


### **6. 기능 수준(feature level)**
　현재 하드웨어의 그래픽카드가 어느정도 Direct 버전까지 지원하는지를 확인하는 열거형 구조체이다.<br />
대략 Dx9버전부터 11까지의 버전들이 들어있다. 실제 응용프로그램에서는 구형 하드웨어를 사용하는 이용자가 있으므로, 해당 구조체로 하드웨어 정보를 파악한 후 그것에 맞는 환경을 제공하는 것을 고려해야 한다.<br />


<br />
<br />
<br />
<br />


### **7. DXGI (DirectX Graphics Infrastructure)**
　DXGI는 D3D와 함께 사용되는 API다. 그래픽 자료들은 포맷은 서로 다르지만 공통된 작업을 필요로 하는 경우가 있다.이렇듯 **<span style="color:red"> 서로 다른 포맷을 가진 자료들의 공통된 그래픽 처리를 담당</span>**하는 것이 DXGI 인터페이스이다. 예를 들어 SWAP CHain은 3d뿐만 아니라 2d 애니메이션에도 매끄러운 움직임을 위해 필수적인 작업이다. 따라서 Swap chain은 d3d가 아닌 DXGI에 소속된 인터페이스 이다.<br />
　그 밖에도 디스플레이 어뎁터나 모니터, 지원되는 디스플레이 모드등 공통적인 그래픽 기능을 열거하는 기능을 DXGI가  제공하고 있다.<br />
<br />

DXGI의 핵심 인터페이스 종류<br />

 - IDXGIFactory : 스왑체인과 디스플레이 어뎁터등을 생성하는 데 사용되는 인터페이스<br />
  - IDXGIAdapter : 여기서 디스플레이 어뎁터는 주로 그래픽카드를 의미한다. 하지만 소프트웨어 디스플레이   어댑터도 존재한다. 컴퓨터에는 여러개의 어댑터가 있을 수 있고(내장그래픽과 외장그래픽) 이를 어느 시점에서 사용할 지 결정시킬 수 있다.
이 때 Microsoft Basic Render Driver는 윈도우 8이상에 포함된 소프트웨어 디스플레이 어댑터이다.
-  IDXGIOutput : 디스플레이 출력<br />
- DXGI_MODE_DESC : 디스플레이 모드 멤버 구조체<br />
- ID3D12Device::CheckFeatureSupport : 하드웨어 기능 지원 여부를 점검할 수 있는 많은 정보들을 담고 있는 함수<br />



<br />
<br />
<br />
<br />


### **8. 상주성(Residency)**
<br />
상주성이란 자원이 GPU메모리에 들어있는 지에 대한 여부를 의미한다.<br />
예를 들어 게임의 레벨이나 지역이 바뀌는 시점에 필요한 자원만 메모리로 올리고 나머지는 메모리에서 내리는 것을 상주성 관리라고 한다.
상주성 관리가 중요한 이유는 GPU를 다른 응용프로그램에서도 사용할 수 있으므로 GPU점유를 프로그램이 최소화 해야한다는 점이다.<br /><br />
하지만 제일 중요한 것은 GPU에 같은 자원을 빠른 시간내에 올렸다 내렸다 하는것을 최대한 피해야 한다는 것이다.  GPU에 자원을 올리는 작업이 비용이 크기 때문이다. 이는 최적화와 밀접한 관련이 있다. 따라서 이상적으로는 한동안 GPU에서 사용하지 않을 자원들만 GPU 메모리에서 내려야한다. 기본적으로 자원을 생성하면 GPU메모리에 입주하며, 파괴되면 메모리에서 나간다. 게임의 볼륨이 커질수록 상주성 관리가 중요하고 직접 관리해 줘야한다.<br />


<br />
<br />
<br />
<br />

