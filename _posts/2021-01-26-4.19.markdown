---
layout: post
title:  "15. 테셀레이션 단계(Tessellation Stage)"
date:   2021-02-19 01:09:01 +0900
categories: jekyll update
---
#### Table of Contents
1.　[**테셀레이션 단계**](#1-테셀레이션-단계)<br><br />
2.　[**덮개 셰이더(Hull shader)**](#2-덮개-셰이더hull-shader)<br />
    　　2.1 [**상수 덮개 세이더(Constant Hull shader)**](#21-상수-덮개-세이더constant-hull-shader)<br>
    　　2.2 [**제어점 덮개 세이더(Control Point Hull shader)**](#22-제어점-덮개-세이더control-point-hull-shader)<br><br />
3.　[**테셀레이터(Tessellator)**](#3-테셀레이터tessellator)<br /><br />
4.　[**영역 셰이더(Domain shader)**](#4-영역-셰이더domain-shader)<br />
<br />
<br />
**<span style="color:red"></span>**

### **1. 테셀레이션 단계**
- 렌더링 파이프라인에서 테셀레이션에 관련된 세 개의 단계를 테셀레이션 단계(Tessellation Stage)라고 한다.<br><br>
- 테셀레이션은 앞 서 배웠듯이 주어진 기하구조(삼각형)을 더 작은 삼각형들로 분할하고, 분할한 삼각형의 좌표를 조정해서 새로운 기하모델을 만드는 과정이다.<br><br>
- 처음부터 고차원의 세밀한 메시를 사용하는 것보다 테셀레이션 단계에서 고차원 모델을 만드는 것에서 얻는 이점은 다음과 같다.
    1. **<span style="color:red">GPU상의 동적 LOD</span>** : 카메라와 물체간의 거리에 따라 동적으로 GPU에서 물체의 메시 수준(세밀도)를 조절할 수 있다. 상대적으로 먼 곳에 있는 물체는 세밀도가 덜 해도 사용자 입장에서 알아채기 쉽지 않기 때문이다. 따라서 먼 곳의 물체를 저수준의 메쉬로 처리하여 연산량을 낮출 수 있다.
    2. **<span style="color:red">효율적인 물리 및 애니메이션 계산</span>** : 물리와 애니메이션을 저수준의 메쉬로 처리하고, 테셀레이션 단계에서 고수준의 메쉬로 업그레이드 시키면 물리와 애니메이션 계산에서 계산량을 많이 줄일 수 있다.
    3. **<span style="color:red">메모리 절약</span>**: 메모리(디스크 or RAM or VRAM)에 저수준의 메쉬를 담아두고, GPU 테셀레이션에서 즉석으로 고수준 메쉬를 만들어 생성함으로써 메모리를 절약할 수 있다.
<br /><br />
- 테셀레이션이 렌더링 파이프라인에서 사용되면, 입력 조립기 단계에서 정점 셰이더에 삼각형들이 제출되지 않고, 대신에 **<span style="color:red">제어점(Control point)</span>**로 이루어진 **<span style="color:red">패치(patch)</span>**들이 제출된다.<br><br>
- 정점 셰이더에서는 제어점을 통해 애니메이션이나 물리 계산을 수행 한 후 테셀레이션 단계로 넘겨준다.
<br><br><br><br><br><br>

### **2. 덮개 셰이더(Hull shader)**
#### **2.1. 상수 덮개 세이더(Constant Hull shader)**
- 상수 덮개 셰이더는 패치마다 실행되는 셰이더 함수로, 제어점들을 받고 메쉬의 **<span style="color:red">테셀레이션 계수(Tesselaation factor)를 출력</span>**한다.<br><br>
- 테셀레이션 계수는 다음 테셀레이션 단계가 패치를 얼마나 세분할 것인지를 결정한다. 즉 삼각형 몇 개로 자를 것인지 세밀도를 나타낸다.<br><br>
- 상수 덮개 셰이더의 입력(제어점 뭉탱이)은 정점 셰이더의 출력형식 VertexOut에 의해 결정된다.<br><br>
- 모든 테셀레이션 계수가 0이면 그 패치는 처리되지 않고 폐기된다. 이를 활용해서 패치 별로 빠른 컬링을 구현할 수 있다.<br><br>

- **<span style="color:red">테셀레이션 펙터를 결정하는 주요 요인</span>**들은 다음과 같다
    1. 카메라와의 거리 : 거리가 가까울 수록 펙터를 높이면 된다.
    2. 화면 영역의 포괄도 : 화면의 픽셀 몇개까지 덮는 지에 따라 저수준~고수준으로 바꿀 수 있다.
    3. 방향 : 물체의 윤곽선을 이루는 삼각형들을 조금 더 세분하면 시점에 따라서도 그럴 듯 한 물체가 된다.
    4. 표면 거칠기 : 거친 표면은 조금 더 세분하면 좋다.
<br><br>

- 테셀레이션 계수를 결정하는 몇가지 조언
    1. 테셀레이션 계수가 1이면 그 메쉬는 테셀레이션 단계 없이 렌더링 하는 것이 낫다. 테셀레이션 단계 거치는 것이 GPU낭비다
    2. 포괄도가 픽셀 여덟 개 미만으로 작은 삼각형은 테셀레이션 안 하는 것이 낫다.
    3. 테셀레이션을 사용하는 메쉬들을 묶어서 처리하는 것이 좋다.(테셀레이션 껐다 켰다하면 부담이 크다)
<br><br><br>

#### **2.2. 제어점 덮개 세이더(Control Point Hull shader)**
- 제어점 덮개 셰이더(Control point hull shader)는 제어점을 받아서 제어점을 출력한다.
- 표면의 표현을 변경할 때 사용한다.
- 제어점 세개인 보통 삼각형을 제어점이 10개인 패치(3차 베이제 삼각형)으로 변환해서 출력, 혹은 제어점을 더 추가해서 원하는 만큼 테셀레이션 할 수 있다.
- 기존 삼각형 메시를 그대로 테셀레이션에 사용할 수 있다는 장점이 있다.
  
<br><br><br><br><br><br>

### **3. 테셀레이터(Tessellator)**
- 이 단계는 프로그래머블한 단계가 아니다.
- Constant Hull shader가 출력한 테셀레이션 계수들에 기초해서 패치들을 본격적으로 테셀레이션 하는 단계이다.
- 구체적인 작업은 전적으로 **<span style="color:red">하드웨어가 제어</span>**한다.

<br><br><br><br><br><br>

### **4. 영역 셰이더(Domain shader)**
- 영역 셰이더는 테셀레이터가 출력한 정점마다 한 번씩 호출된다.
- 테셀레이션된 패치들의 정점을 동차 절단 공간으로(VDC)로 변환하는 장소이다.(원래 정점셰이더에서 했던 역할)
- 영역 셰이더는 테셀레이션된 패치들의 정점들(Control point)들을 해당 패치공간에 비례하는 uv좌표로 받고, 이를 **<span style="color:red">3차원 공간에 어떤 지점에 위치 시킬 것인가에 대한 제어</span>**를 수행하게 된다.
- 삼각형 패치는 uv 값 대신 삼각형의 무게중심좌표 uvw가 입력된다.

<br><br><br><br><br><br>