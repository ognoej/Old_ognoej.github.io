---
layout: post
title:  "11. 블렌딩"
date:   2021-02-11 01:09:01 +0900
categories: jekyll update
---
#### Table of Contents
1.　[**혼합 공식(Blende)**](#1-혼합-공식blende)<br>
2.　[**혼합 연산**](#2-혼합-연산)<br />
3.　[**혼합 계수(Blend Factor)**](#3-혼합-계수blend-factor)<br />
4.　[**혼합 상태(Blend State)**](#4-혼합-상태blend-state)<br />
5.　[**픽셀 잘라내기(Pixel Clipping)**](#5-픽셀-잘라내기pixel-clipping)<br />
6.　[**안개 효과(Fog)**](#6-안개-효과fog)<br />
<br />
<br />
**<span style="color:red"></span>**

### **1. 혼합 공식(Blende)**

```
C = Csrc X Fsrc + Cdst X Fdst
```
- F는 사용자가 설정하는 혼합 계수(blend factor)로, 설정한 값만 큼 두 픽셀을 적절히 섞어서 최종 색상 C를 후면버퍼에 렌더한다
- 위 혼합 공식은 RGB색상에만 적용하고, 알파채널은 개별적인 공식으로 연산한다.

```
A = AsrcFsrc + AdstFdst
```
- 알파채널은 색상의 투명도 속성이므로, RGB와 독립적인 방식으로 혼합할 수 있게끔 따로 연산을 분리시켜놓았다.
- 알파 혼합은 사실상 많이 사용되지는 않는다.
<br><br><br><br><br><br>


### **2. 혼합 연산**
- 혼합 공식의 이항연산자로 사용되는 블렌드 구조체
```
typedef enum D3D12_BLEND_OP
{
  D3D12_BLEND_OP_ADD = 1,
  D3D12_BLEND_OP_SUBTRACT = 2,
  D3D12_BLEND_OP_REV_SUBTRACT = 3,
  D3D12_BLEND_OP_MIN = 4,
  D3D12_BLEND_OP_MAX = 5,
}
```
- min, max 연산에는 블렌드 펙터가 아무런 적용이 되지 않는다.
- D3D 새로운 버전부터 위의 혼합 공식 대신 논리연산자를 적용하여 색을 혼합할 수 있는 기능이 추가되었다ㅣ.
- 논리 색 혼합에는 반드시 부호없는 정수형식의 픽셀 값만 처리할 수 있음을 유의해야한다.

<br><br><br><br><br><br>


### **3. 혼합 계수(Blend Factor)**
- 혼합식에 사용되는 혼합 계수는 D3D에서 정해진 다양한 Define값이 존재한다.
```
  D3D12_BLEND_ZERO
  D3D12_BLEND_ONE
  D3D12_BLEND_SRC_COLOR
  D3D12_BLEND_INV_SRC_COLOR
  D3D12_BLEND_ALPHA
  ...
  D3D12_BLEND_BLEND_FACTOR
  // 해당 값으로 사용자가 직접 r,g,b,a값을 설정하여 혼합 계수를 지정할 수도 있다.
  // 위 값은 GraphicsCommandList::OMSetBlendFactor 매서드의 두 번째 매개변수로 주어진 색상이다.
```
- GraphicsCommandList::OMSetBlendFactor(const FLOAT BlendFactor[4]); 의 매서드로 혼합 계수 직접 설정이 가능한데, nullptr을 주면 기본 혼합 계수인(1,1,1,1)이 디폴트 값으로 적용된다.
<br><br><br><br><br><br>


### **4. 혼합 상태(Blend State)**
- 지금 까지 혼합 공식을 봤다면 이제 파이프라인의 한 상태로 블렌딩을 적용시켜야할 차례이다.
- 디폴트 값은 혼합이 비활성화된 상태이다.
- 블렌딩을 활성화 하려면 블렌딩 객체를 채워서 파이프라인에 꽃아야한다.
  
**블렌드 구조체**
```
typedef sturct D3D12_BLEND_DESC
{
  BOOL AlphaToConverageEnable;
  BOOL IndependentBlendEnable;
  D3D12_RENDER_TARGET_BLEND_DESC RenderTarget[8];
}
```
- 첫 번 째 매개변수는 알파 포괄도(AlphaToCoverage) 변환 활성화 이다. 알파 포괄도 변환은 식물군엽이나 창살 텍스쳐 렌더링에 유용한 MultiSampling 기법이다.
- 두 번째 매개변수를 활성화하면, 한 장면을 이루는 렌더 타겟들을 각각 다른 혼합방식으로 적용할 수 있게 된다.
- 세 번째 매개변수는 i번째 렌더 타겟에 적용할 블렌드 구조체 정보를 담고있다. false로 놓으면 0번째 변수가 모든 렌더 타겟의 혼합에 사용된다.

- 혼합은 픽셀마다 추가적인 연산을 수행하므로 비용이 크다. 따라서 필요한 경우에만 혼합을 활성화하고, 혼합 처리가 끝나면 비활성화 해야한다.
- 다른 파이프라인과 마찬가지로, 블렌딩도 프로그램 초기화 시점에 모두 만들어 놓고, 필요한 렌더링에서 가져다 사용하는 방식으로 적용하면 된다.

***tips***
- 투명한 물체(물 등)를 렌더 할 때 일련의 순서를 따라 렌더하면 간결해진다
```
1. 혼합을 사용하지 않는 물체를 먼저 그린다
2. 혼합을 사용할 물체를 깊이 버퍼에 따라 정렬한다.
3. 혼합 사용할 물체를 카메라와 먼 곳 부터 그린다.
```
- 혼합 사용하지 않는 물체를 먼저 그리는 이유는, 깊이 버퍼에 따라 후면에 투명한 픽셀만 남고 원래의 색상이 기록되지 않을 수 있기 때문이다.
- 혼합 물체에 대해 깊이버퍼를 사용하지 않는 코드를 구현한다면 혼합 물체를 따로 정렬할 필요가 없어진다.
- 따라서 혼합물체를 처리하는 동안만 Depth Buffer 기록을 비활성화하는 방식으로 혼합물체를 그리는 것이 좋다.
- 깊이 기록만 처리 안하는 것일 뿐 깊이 비교는 이루어져야 물체가 제대로 가려진다.


<br><br><br><br><br><br>


### **5. 픽셀 잘라내기(Pixel Clipping)**
- 원본 픽셀을 불러오기 단계에서 특정 색상일 경우 아예 렌더링에서 배재시키는 Clipping 기법을 사용할 수도 있다.
- Clipping을 사용하게 되면 픽셀 연산을 수행할 필요가 없어져 연산량이 감소되는 효과가 있다.
- Clip은 셰이더에서 최대한 일찍 판정하는 것이 나머지 픽셀 연산을 생략하므로 효율적이다.
- 하지만 클리핑의 비교연산이 비용이 큰 편이기 때문에 필요한 경우가 아니라면 사용하지 않는 것이 좋다.

<br><br><br><br><br><br>


### **6. 안개 효과(Fog)**
- 안개 효과는 기상표현과 원근감 구현에 효과적인 방법이다.
- 안개 표현 방법은 다음과 같다

```
1. 안개 범위와 색상을 설정한다.
2. 물체의 한 점 색상을 구할 때 거리에 따라 안개 색상에 가중치를 두어 
   혼합한다.
3. 멀리 있으면 안개 색상을 더 많이, 안개 범위 밖으로 나간 물체는 안개에 
   가려져 안보이게 된다.
4. 물체가 안개 시작범위 안쪽에 있으면 안개 색상에 아무런 영향을 받지 않는다.
```

<br><br><br><br><br><br>